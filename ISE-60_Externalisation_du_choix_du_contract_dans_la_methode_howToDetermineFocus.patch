Index: src/main/java/fr/unice/polytech/si3/qgl/ise/BasicContractChoser.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/fr/unice/polytech/si3/qgl/ise/BasicContractChoser.java	(revision d681fe2581e16328f16c94e4a0fda32942d18b3c)
+++ src/main/java/fr/unice/polytech/si3/qgl/ise/BasicContractChoser.java	(revision d681fe2581e16328f16c94e4a0fda32942d18b3c)
@@ -0,0 +1,38 @@
+package fr.unice.polytech.si3.qgl.ise;
+
+import java.util.Comparator;
+import java.util.List;
+import java.util.Optional;
+
+public class BasicContractChoser extends ContractChoser {
+    public BasicContractChoser(List<RawContract> rawContracts, List<CraftedContract> craftedContracts) {
+        super(rawContracts, craftedContracts);
+    }
+
+    /**
+     * Chooses the contract with the least resources to collect
+     *
+     * @return the contract
+     */
+    private Contract choseBestRawContract() {
+        if (getRawContracts().isEmpty())
+            return null;
+        return getRawContracts().stream().max(Comparator.comparingInt(RawContract::getQuantity)).orElse(null);
+    }
+
+    private Contract choseBestCraftedContract() {
+        if (getCraftedContracts().isEmpty())
+            return null;
+        return getCraftedContracts().stream().max(Comparator.comparingInt(CraftedContract::getRemainingQuantity)).orElse(null);
+    }
+
+    @Override
+    public Optional<Contract> chooseBestContract() {
+        Contract bestRawContract = choseBestRawContract();
+        Contract bestCraftedContract = choseBestCraftedContract();
+        return bestRawContract != null ?
+                Optional.of(bestRawContract) :
+                bestCraftedContract != null ?
+                        Optional.of(bestCraftedContract) : Optional.empty();
+    }
+}
Index: src/main/java/fr/unice/polytech/si3/qgl/ise/Contract.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/fr/unice/polytech/si3/qgl/ise/Contract.java	(revision d681fe2581e16328f16c94e4a0fda32942d18b3c)
+++ src/main/java/fr/unice/polytech/si3/qgl/ise/Contract.java	(revision d681fe2581e16328f16c94e4a0fda32942d18b3c)
@@ -0,0 +1,9 @@
+package fr.unice.polytech.si3.qgl.ise;
+
+import fr.unice.polytech.si3.qgl.ise.enums.RawResource;
+
+import java.util.Map;
+
+public interface Contract {
+    Map<RawResource, Double> getTotalRessourcesToCollect();
+}
Index: src/main/java/fr/unice/polytech/si3/qgl/ise/ContractChoser.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/fr/unice/polytech/si3/qgl/ise/ContractChoser.java	(revision d681fe2581e16328f16c94e4a0fda32942d18b3c)
+++ src/main/java/fr/unice/polytech/si3/qgl/ise/ContractChoser.java	(revision d681fe2581e16328f16c94e4a0fda32942d18b3c)
@@ -0,0 +1,24 @@
+package fr.unice.polytech.si3.qgl.ise;
+
+import java.util.List;
+import java.util.Optional;
+
+public abstract class ContractChoser {
+    private List<RawContract> rawContracts;
+    private List<CraftedContract> craftedContracts;
+
+    public ContractChoser(List<RawContract> rawContracts, List<CraftedContract> craftedContracts) {
+        this.rawContracts = rawContracts;
+        this.craftedContracts = craftedContracts;
+    }
+
+    public List<RawContract> getRawContracts() {
+        return rawContracts;
+    }
+
+    public List<CraftedContract> getCraftedContracts() {
+        return craftedContracts;
+    }
+
+    public abstract Optional<Contract> chooseBestContract();
+}
Index: src/main/java/fr/unice/polytech/si3/qgl/ise/CraftedContract.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/fr/unice/polytech/si3/qgl/ise/CraftedContract.java	(revision 9aac72e34c5815a63760b1e228df021ca81f6197)
+++ src/main/java/fr/unice/polytech/si3/qgl/ise/CraftedContract.java	(revision d681fe2581e16328f16c94e4a0fda32942d18b3c)
@@ -6,7 +6,7 @@
 import java.util.EnumMap;
 import java.util.Map;
 
-public class CraftedContract {
+public class CraftedContract implements Contract {
     private final Integer quantity;
     private final CraftedResource resource;
     private final Map<RawResource, Double> rawQuantities;
@@ -72,6 +72,11 @@
         return remainingRawQuantitiesMinusStock;
     }
 
+    @Override
+    public Map<RawResource, Double> getTotalRessourcesToCollect() {
+        return rawQuantities;
+    }
+
     @Override
     public String toString() {
         return quantity + " " + resource;
Index: src/main/java/fr/unice/polytech/si3/qgl/ise/RawContract.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/fr/unice/polytech/si3/qgl/ise/RawContract.java	(revision 9aac72e34c5815a63760b1e228df021ca81f6197)
+++ src/main/java/fr/unice/polytech/si3/qgl/ise/RawContract.java	(revision d681fe2581e16328f16c94e4a0fda32942d18b3c)
@@ -2,7 +2,10 @@
 
 import fr.unice.polytech.si3.qgl.ise.enums.RawResource;
 
-public class RawContract {
+import java.util.HashMap;
+import java.util.Map;
+
+public class RawContract implements Contract {
     private final Integer quantity;
     private final RawResource resource;
     private int remainingQuantity;
@@ -33,4 +36,10 @@
     public String toString() {
         return quantity + " " + resource;
     }
+
+    public Map<RawResource, Double> getTotalRessourcesToCollect() {
+        HashMap<RawResource, Double> result = new HashMap<>();
+        result.put(resource, (double) remainingQuantity);
+        return result;
+    }
 }
Index: src/main/java/fr/unice/polytech/si3/qgl/ise/entities/Crew.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/fr/unice/polytech/si3/qgl/ise/entities/Crew.java	(revision 9aac72e34c5815a63760b1e228df021ca81f6197)
+++ src/main/java/fr/unice/polytech/si3/qgl/ise/entities/Crew.java	(revision d681fe2581e16328f16c94e4a0fda32942d18b3c)
@@ -1,8 +1,6 @@
 package fr.unice.polytech.si3.qgl.ise.entities;
 
-import fr.unice.polytech.si3.qgl.ise.CraftedContract;
-import fr.unice.polytech.si3.qgl.ise.Explorer;
-import fr.unice.polytech.si3.qgl.ise.RawContract;
+import fr.unice.polytech.si3.qgl.ise.*;
 import fr.unice.polytech.si3.qgl.ise.actions.Action;
 import fr.unice.polytech.si3.qgl.ise.actions.CrewAction;
 import fr.unice.polytech.si3.qgl.ise.actions.StopAction;
@@ -51,7 +49,7 @@
         this.doNotEstimate = false;
 
         computeWantedResources();
-        chooseNewFocus();
+        chooseNewFocus(howToChoseContract());
 
         idCreek = PathFinder.findBestCreek(map, wantedResources);
         coordinates = map.getCreeks().get(idCreek);
@@ -59,22 +57,6 @@
         initActions();
     }
 
-    /**
-     * Chooses the contract with the least resources to collect
-     *
-     * @return the contract
-     */
-    private Optional<RawContract> choseBestRawContract() {
-        if (rawContracts.isEmpty())
-            return Optional.empty();
-        return rawContracts.stream().max(Comparator.comparingInt(RawContract::getQuantity));
-    }
-
-    private Optional<CraftedContract> choseBestCraftedContract() {
-        if (craftedContracts.isEmpty())
-            return Optional.empty();
-        return craftedContracts.stream().max(Comparator.comparingInt(CraftedContract::getRemainingQuantity));
-    }
 
     private void initActions() {
         steps = new ArrayList<>();
@@ -133,35 +115,69 @@
         craftedStock.put(resource, amount);
     }
 
-    private void chooseNewFocus() {
+    private void chooseNewFocus(ContractChoser howToDertemine) {
         currentResource = null;
 
-        Optional<RawContract> bestContract = choseBestRawContract();
-        bestContract.ifPresent(rawContract -> currentResource = rawContract.getResource());
-        if (currentResource == null) {
-            Optional<CraftedContract> bestCraftedContract = choseBestCraftedContract();
-            if (bestCraftedContract.isPresent()) {
-                Map<RawResource, Double> resources = bestCraftedContract.get().getRemainingRawQuantities();
-                for (Map.Entry<RawResource, Double> entry : resources.entrySet()) {
-                    int realStock;
-                    if (stock.containsKey(entry.getKey())) {
-                        realStock = stock.get(entry.getKey());
-                        for (RawContract rawContract : completedRawContracts) {
-                            if (rawContract.getResource().equals(entry.getKey())) {
-                                realStock = realStock - rawContract.getQuantity();
-                            }
-                        }
-                        if (realStock < entry.getValue()) {
-                            currentResource = entry.getKey();
-                            return;
-                        }
-                    } else {
-                        currentResource = entry.getKey();
-                        return;
-                    }
+        Optional<Contract> bestContract = howToDertemine.chooseBestContract();
+        bestContract.ifPresent(contract -> {
+            for (Map.Entry<RawResource, Double> entry : contract.getTotalRessourcesToCollect().entrySet()) {
+                int realStock;
+                // If we don't have it in stock, we focus it
+                if (stock.containsKey(entry.getKey())) {
+                    realStock = stock.get(entry.getKey());
+                    System.out.println("Stock : " + realStock);
+                    // Else, we calculate if the stock isn't really enough
+
+                    // We calculate the amount of the resource used in rawContracts
+                    for (RawContract rawContract : completedRawContracts) {
+                        if (rawContract.getResource().equals(entry.getKey())) {
+                            realStock = realStock - rawContract.getQuantity();
+                        }
+                    }
+
+                    // We calculate the amount of the resource used in CraftedContracts
+                    for (CraftedContract craftedContract : completedCraftedContracts) {
+                        if (craftedContract.getRawQuantities().containsKey(entry.getKey()))
+                            realStock = realStock - craftedContract.getRawQuantities().get(entry.getKey()).intValue();
+                    }
+
+                    if (realStock < entry.getValue()) {
+                        currentResource = entry.getKey();
+                        return;
+                    }
+                } else {
+                    currentResource = entry.getKey();
+                    return;
                 }
             }
-        }
+        });
+
+//        Optional<RawContract> bestContract = choseBestRawContract();
+//        bestContract.ifPresent(rawContract -> currentResource = rawContract.getResource());
+//        if (currentResource == null) {
+//            Optional<CraftedContract> bestCraftedContract = choseBestCraftedContract();
+//            if (bestCraftedContract.isPresent()) {
+//                Map<RawResource, Double> resources = bestCraftedContract.get().getRemainingRawQuantities();
+//                for (Map.Entry<RawResource, Double> entry : resources.entrySet()) {
+//                    int realStock;
+//                    if (stock.containsKey(entry.getKey())) {
+//                        realStock = stock.get(entry.getKey());
+//                        for (RawContract rawContract : completedRawContracts) {
+//                            if (rawContract.getResource().equals(entry.getKey())) {
+//                                realStock = realStock - rawContract.getQuantity();
+//                            }
+//                        }
+//                        if (realStock < entry.getValue()) {
+//                            currentResource = entry.getKey();
+//                            return;
+//                        }
+//                    } else {
+//                        currentResource = entry.getKey();
+//                        return;
+//                    }
+//                }
+//            }
+//        }
     }
 
     public void tryToFinishContracts() {
@@ -191,8 +207,23 @@
         });
 
         computeWantedResources();
+        chooseNewFocus(howToChoseContract());
+    }
 
-        chooseNewFocus();
+    /**
+     * We decide here how to determine the next Best contract based on contracts left and current crew
+     *
+     * @return the ContractChose that we need at the moment
+     */
+    private ContractChoser howToChoseContract() {
+        List<RawContract> rawContractsLeft = rawContracts;
+        rawContractsLeft.removeAll(abortedRawContracts);
+        rawContractsLeft.removeAll(completedRawContracts);
+
+        List<CraftedContract> craftedContractsLeft = craftedContracts;
+        craftedContractsLeft.removeAll(abortedCraftedContracts);
+        craftedContractsLeft.removeAll(completedCraftedContracts);
+        return new BasicContractChoser(rawContractsLeft, craftedContractsLeft);
     }
 
     public Map<RawResource, Double> tryCrafting() {
